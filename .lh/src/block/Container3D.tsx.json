{
    "sourceFile": "src/block/Container3D.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 32,
            "patches": [
                {
                    "date": 1747721781486,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1747721936483,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2,14 +2,14 @@\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n \n const Container3D: React.FC = () => {\n-  const [rotateY, setRotateY] = useState(0);\n+  const [rotateX, setRotateX] = useState(0);\n   const containerRef = useRef<HTMLDivElement>(null);\n \n   const handleWheel = (e: WheelEvent) => {\n     e.preventDefault();\n-    setRotateY(prev => prev + e.deltaY * 0.1);\n+    setRotateX(prev => Math.max(-90, Math.min(90, prev + e.deltaY * 0.1)));\n   };\n \n   useEffect(() => {\n     const el = containerRef.current;\n@@ -42,9 +42,9 @@\n           width: 1200,\n           height: 600,\n           display: 'flex',\n           transformStyle: 'preserve-3d',\n-          transform: `rotateY(${rotateY}deg)`,\n+          transform: `rotateX(${rotateX}deg)`,\n           transition: 'transform 0.1s ease-out',\n         }}\n       >\n         {colors.map((color, index) => (\n@@ -62,9 +62,9 @@\n               color: '#fff',\n               border: '1px solid #000',\n             }}\n           >\n-            {Math.round(rotateY)}°\n+            {Math.round(rotateX)}°\n           </div>\n         ))}\n       </div>\n     </div>\n"
                },
                {
                    "date": 1747722015457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,17 +32,17 @@\n         perspective: '1000px',\n         display: 'flex',\n         alignItems: 'center',\n         justifyContent: 'center',\n+        background: '#111',\n         overflow: 'hidden',\n-        background: '#111',\n       }}\n     >\n       <div\n         style={{\n+          position: 'relative',\n           width: 1200,\n-          height: 600,\n-          display: 'flex',\n+          height: 600 + (colors.length - 1) * 700,\n           transformStyle: 'preserve-3d',\n           transform: `rotateX(${rotateX}deg)`,\n           transition: 'transform 0.1s ease-out',\n         }}\n@@ -50,18 +50,23 @@\n         {colors.map((color, index) => (\n           <div\n             key={index}\n             style={{\n-              width: 400,\n+              position: 'absolute',\n+              top: 0,\n+              left: 0,\n+              width: 1200,\n               height: 600,\n               backgroundColor: color,\n+              transform: `translateY(${index * 700}px)`,\n               display: 'flex',\n               alignItems: 'center',\n               justifyContent: 'center',\n               fontSize: '32px',\n               fontWeight: 'bold',\n               color: '#fff',\n-              border: '1px solid #000',\n+              border: '2px solid #000',\n+              boxSizing: 'border-box',\n             }}\n           >\n             {Math.round(rotateX)}°\n           </div>\n"
                },
                {
                    "date": 1747722204985,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,76 +3,72 @@\n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n \n const Container3D: React.FC = () => {\n   const [rotateX, setRotateX] = useState(0);\n-  const containerRef = useRef<HTMLDivElement>(null);\n+  const isDragging = useRef(false);\n+  const startY = useRef(0);\n+  const lastRotate = useRef(0);\n \n-  const handleWheel = (e: WheelEvent) => {\n-    e.preventDefault();\n-    setRotateX(prev => Math.max(-90, Math.min(90, prev + e.deltaY * 0.1)));\n+  const handleMouseDown = (e: React.MouseEvent) => {\n+    isDragging.current = true;\n+    startY.current = e.clientY;\n   };\n \n+  const handleMouseMove = (e: MouseEvent) => {\n+    if (!isDragging.current) return;\n+    const delta = e.clientY - startY.current;\n+    const nextRotate = lastRotate.current + delta * 0.2;\n+    setRotateX(nextRotate);\n+  };\n+\n+  const handleMouseUp = () => {\n+    isDragging.current = false;\n+    lastRotate.current = rotateX;\n+  };\n+\n   useEffect(() => {\n-    const el = containerRef.current;\n-    if (el) {\n-      el.addEventListener('wheel', handleWheel, { passive: false });\n-    }\n+    window.addEventListener('mousemove', handleMouseMove);\n+    window.addEventListener('mouseup', handleMouseUp);\n     return () => {\n-      if (el) {\n-        el.removeEventListener('wheel', handleWheel);\n-      }\n+      window.removeEventListener('mousemove', handleMouseMove);\n+      window.removeEventListener('mouseup', handleMouseUp);\n     };\n-  }, []);\n+  }, [rotateX]);\n \n   return (\n     <div\n-      ref={containerRef}\n       style={{\n         width: '100vw',\n-        height: '100vh',\n-        perspective: '1000px',\n-        display: 'flex',\n-        alignItems: 'center',\n-        justifyContent: 'center',\n+        minHeight: '100vh',\n         background: '#111',\n-        overflow: 'hidden',\n+        overflowY: 'auto',\n+        padding: '100px 0',\n       }}\n+      onMouseDown={handleMouseDown}\n     >\n-      <div\n-        style={{\n-          position: 'relative',\n-          width: 1200,\n-          height: 600 + (colors.length - 1) * 700,\n-          transformStyle: 'preserve-3d',\n-          transform: `rotateX(${rotateX}deg)`,\n-          transition: 'transform 0.1s ease-out',\n-        }}\n-      >\n-        {colors.map((color, index) => (\n-          <div\n-            key={index}\n-            style={{\n-              position: 'absolute',\n-              top: 0,\n-              left: 0,\n-              width: 1200,\n-              height: 600,\n-              backgroundColor: color,\n-              transform: `translateY(${index * 700}px)`,\n-              display: 'flex',\n-              alignItems: 'center',\n-              justifyContent: 'center',\n-              fontSize: '32px',\n-              fontWeight: 'bold',\n-              color: '#fff',\n-              border: '2px solid #000',\n-              boxSizing: 'border-box',\n-            }}\n-          >\n-            {Math.round(rotateX)}°\n-          </div>\n-        ))}\n-      </div>\n+      {colors.map((color, index) => (\n+        <div\n+          key={index}\n+          style={{\n+            width: 1200,\n+            height: 600,\n+            margin: '0 auto 100px',\n+            backgroundColor: color,\n+            transform: `rotateX(${rotateX}deg)`,\n+            transformStyle: 'preserve-3d',\n+            transition: isDragging.current ? 'none' : 'transform 0.1s ease-out',\n+            display: 'flex',\n+            alignItems: 'center',\n+            justifyContent: 'center',\n+            fontSize: '32px',\n+            fontWeight: 'bold',\n+            color: '#fff',\n+            border: '2px solid #000',\n+          }}\n+        >\n+          {Math.round(rotateX)}°\n+        </div>\n+      ))}\n     </div>\n   );\n };\n \n"
                },
                {
                    "date": 1747722322653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,12 +3,16 @@\n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n \n const Container3D: React.FC = () => {\n   const [rotateX, setRotateX] = useState(0);\n+  const [scrollY, setScrollY] = useState(0);\n   const isDragging = useRef(false);\n   const startY = useRef(0);\n   const lastRotate = useRef(0);\n \n+  const containerRef = useRef<HTMLDivElement>(null);\n+\n+  // 마우스 드래그 회전\n   const handleMouseDown = (e: React.MouseEvent) => {\n     isDragging.current = true;\n     startY.current = e.clientY;\n   };\n@@ -24,51 +28,69 @@\n     isDragging.current = false;\n     lastRotate.current = rotateX;\n   };\n \n+  // 스크롤 위치 추적\n+  const handleScroll = () => {\n+    setScrollY(window.scrollY);\n+  };\n+\n   useEffect(() => {\n     window.addEventListener('mousemove', handleMouseMove);\n     window.addEventListener('mouseup', handleMouseUp);\n+    window.addEventListener('scroll', handleScroll);\n     return () => {\n       window.removeEventListener('mousemove', handleMouseMove);\n       window.removeEventListener('mouseup', handleMouseUp);\n+      window.removeEventListener('scroll', handleScroll);\n     };\n   }, [rotateX]);\n \n   return (\n     <div\n+      ref={containerRef}\n+      onMouseDown={handleMouseDown}\n       style={{\n+        position: 'relative',\n         width: '100vw',\n-        minHeight: '100vh',\n+        height: `${colors.length * 700 + 100}px`,\n         background: '#111',\n         overflowY: 'auto',\n-        padding: '100px 0',\n+        cursor: isDragging.current ? 'grabbing' : 'default',\n       }}\n-      onMouseDown={handleMouseDown}\n     >\n-      {colors.map((color, index) => (\n-        <div\n-          key={index}\n-          style={{\n-            width: 1200,\n-            height: 600,\n-            margin: '0 auto 100px',\n-            backgroundColor: color,\n-            transform: `rotateX(${rotateX}deg)`,\n-            transformStyle: 'preserve-3d',\n-            transition: isDragging.current ? 'none' : 'transform 0.1s ease-out',\n-            display: 'flex',\n-            alignItems: 'center',\n-            justifyContent: 'center',\n-            fontSize: '32px',\n-            fontWeight: 'bold',\n-            color: '#fff',\n-            border: '2px solid #000',\n-          }}\n-        >\n-          {Math.round(rotateX)}°\n-        </div>\n-      ))}\n+      {colors.map((color, index) => {\n+        const initialY = index * 700;\n+        const endY = initialY * 0.1;\n+        const visibleY = Math.max(0, initialY - scrollY);\n+        const top = Math.max(endY, visibleY);\n+\n+        return (\n+          <div\n+            key={index}\n+            style={{\n+              position: 'absolute',\n+              top,\n+              left: '50%',\n+              transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n+              width: 1200,\n+              height: 600,\n+              backgroundColor: color,\n+              display: 'flex',\n+              alignItems: 'center',\n+              justifyContent: 'center',\n+              fontSize: '32px',\n+              fontWeight: 'bold',\n+              color: '#fff',\n+              border: '2px solid #000',\n+              transition: 'top 0.2s ease-out',\n+              zIndex: index,\n+            }}\n+          >\n+            {Math.round(rotateX)}°\n+          </div>\n+        );\n+      })}\n     </div>\n   );\n };\n \n"
                },
                {
                    "date": 1747722385790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n         cursor: isDragging.current ? 'grabbing' : 'default',\n       }}\n     >\n       {colors.map((color, index) => {\n-        const initialY = index * 700;\n+        const initialY = index * 1000;\n         const endY = initialY * 0.1;\n         const visibleY = Math.max(0, initialY - scrollY);\n         const top = Math.max(endY, visibleY);\n \n"
                },
                {
                    "date": 1747722711769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,76 +1,50 @@\n-import React, { useEffect, useRef, useState } from 'react';\n+import React, { useEffect, useState } from 'react';\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n+const containerHeight = 600;\n+const gap = 100;\n+const step = containerHeight + gap;\n+const maxRotateXList = [-30, -15, 0]; // 마지막은 회전 없음\n \n-const Container3D: React.FC = () => {\n-  const [rotateX, setRotateX] = useState(0);\n+const Container3DScroll: React.FC = () => {\n   const [scrollY, setScrollY] = useState(0);\n-  const isDragging = useRef(false);\n-  const startY = useRef(0);\n-  const lastRotate = useRef(0);\n \n-  const containerRef = useRef<HTMLDivElement>(null);\n-\n-  // 마우스 드래그 회전\n-  const handleMouseDown = (e: React.MouseEvent) => {\n-    isDragging.current = true;\n-    startY.current = e.clientY;\n-  };\n-\n-  const handleMouseMove = (e: MouseEvent) => {\n-    if (!isDragging.current) return;\n-    const delta = e.clientY - startY.current;\n-    const nextRotate = lastRotate.current + delta * 0.2;\n-    setRotateX(nextRotate);\n-  };\n-\n-  const handleMouseUp = () => {\n-    isDragging.current = false;\n-    lastRotate.current = rotateX;\n-  };\n-\n-  // 스크롤 위치 추적\n-  const handleScroll = () => {\n-    setScrollY(window.scrollY);\n-  };\n-\n   useEffect(() => {\n-    window.addEventListener('mousemove', handleMouseMove);\n-    window.addEventListener('mouseup', handleMouseUp);\n+    const handleScroll = () => {\n+      setScrollY(window.scrollY);\n+    };\n     window.addEventListener('scroll', handleScroll);\n-    return () => {\n-      window.removeEventListener('mousemove', handleMouseMove);\n-      window.removeEventListener('mouseup', handleMouseUp);\n-      window.removeEventListener('scroll', handleScroll);\n-    };\n-  }, [rotateX]);\n+    return () => window.removeEventListener('scroll', handleScroll);\n+  }, []);\n \n   return (\n     <div\n-      ref={containerRef}\n-      onMouseDown={handleMouseDown}\n       style={{\n         position: 'relative',\n         width: '100vw',\n-        height: `${colors.length * 700 + 100}px`,\n+        height: `${colors.length * step + 100}px`,\n         background: '#111',\n         overflowY: 'auto',\n-        cursor: isDragging.current ? 'grabbing' : 'default',\n       }}\n     >\n       {colors.map((color, index) => {\n-        const initialY = index * 1000;\n-        const endY = initialY * 0.1;\n-        const visibleY = Math.max(0, initialY - scrollY);\n-        const top = Math.max(endY, visibleY);\n+        const initialY = index * step;\n+        const nextInitialY = (index + 1) * step;\n+        const maxRotate = maxRotateXList[index];\n \n+        let rotateX = 0;\n+        if (maxRotate !== 0 && scrollY >= nextInitialY) {\n+          const progress = Math.min(1, (scrollY - nextInitialY) / step);\n+          rotateX = progress * maxRotate;\n+        }\n+\n         return (\n           <div\n             key={index}\n             style={{\n               position: 'absolute',\n-              top,\n+              top: initialY,\n               left: '50%',\n               transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               width: 1200,\n               height: 600,\n@@ -81,17 +55,17 @@\n               fontSize: '32px',\n               fontWeight: 'bold',\n               color: '#fff',\n               border: '2px solid #000',\n-              transition: 'top 0.2s ease-out',\n-              zIndex: index,\n+              transition: 'transform 0.2s ease-out',\n+              zIndex: colors.length - index, // 아래 있는 게 더 위로 올라오게\n             }}\n           >\n-            {Math.round(rotateX)}°\n+            {rotateX.toFixed(1)}°\n           </div>\n         );\n       })}\n     </div>\n   );\n };\n \n-export default Container3D;\n+export default Container3DScroll;\n"
                },
                {
                    "date": 1747722783648,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,17 +3,15 @@\n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n const gap = 100;\n const step = containerHeight + gap;\n-const maxRotateXList = [-30, -15, 0]; // 마지막은 회전 없음\n+const maxRotateXList = [-30, -15, 0];\n \n-const Container3DScroll: React.FC = () => {\n+const Container3DStackScroll: React.FC = () => {\n   const [scrollY, setScrollY] = useState(0);\n \n   useEffect(() => {\n-    const handleScroll = () => {\n-      setScrollY(window.scrollY);\n-    };\n+    const handleScroll = () => setScrollY(window.scrollY);\n     window.addEventListener('scroll', handleScroll);\n     return () => window.removeEventListener('scroll', handleScroll);\n   }, []);\n \n@@ -23,16 +21,21 @@\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n         background: '#111',\n-        overflowY: 'auto',\n       }}\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n         const nextInitialY = (index + 1) * step;\n+        const endY = initialY * 0.1;\n+\n+        // top 계산 (스택처럼 올라오게)\n+        const visibleY = Math.max(0, initialY - scrollY);\n+        const top = Math.max(endY, visibleY);\n+\n+        // 회전 계산 (다음 컨테이너가 도달하면 회전 시작)\n         const maxRotate = maxRotateXList[index];\n-\n         let rotateX = 0;\n         if (maxRotate !== 0 && scrollY >= nextInitialY) {\n           const progress = Math.min(1, (scrollY - nextInitialY) / step);\n           rotateX = progress * maxRotate;\n@@ -42,9 +45,9 @@\n           <div\n             key={index}\n             style={{\n               position: 'absolute',\n-              top: initialY,\n+              top,\n               left: '50%',\n               transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               width: 1200,\n               height: 600,\n@@ -55,10 +58,10 @@\n               fontSize: '32px',\n               fontWeight: 'bold',\n               color: '#fff',\n               border: '2px solid #000',\n-              transition: 'transform 0.2s ease-out',\n-              zIndex: colors.length - index, // 아래 있는 게 더 위로 올라오게\n+              transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n+              zIndex: colors.length - index,\n             }}\n           >\n             {rotateX.toFixed(1)}°\n           </div>\n@@ -67,5 +70,5 @@\n     </div>\n   );\n };\n \n-export default Container3DScroll;\n+export default Container3DStackScroll;\n"
                },
                {
                    "date": 1747722809582,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n         const nextInitialY = (index + 1) * step;\n-        const endY = initialY * 0.1;\n+        const endY = initialY * 0.9;\n \n         // top 계산 (스택처럼 올라오게)\n         const visibleY = Math.max(0, initialY - scrollY);\n         const top = Math.max(endY, visibleY);\n"
                },
                {
                    "date": 1747722831467,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,9 @@\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n         const nextInitialY = (index + 1) * step;\n-        const endY = initialY * 0.9;\n+        const endY = initialY * 0.1;\n \n         // top 계산 (스택처럼 올라오게)\n         const visibleY = Math.max(0, initialY - scrollY);\n         const top = Math.max(endY, visibleY);\n"
                },
                {
                    "date": 1747722891588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,10 @@\n               fontWeight: 'bold',\n               color: '#fff',\n               border: '2px solid #000',\n               transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n-              zIndex: colors.length - index,\n+              zIndex: index,\n+\n             }}\n           >\n             {rotateX.toFixed(1)}°\n           </div>\n"
                },
                {
                    "date": 1747723050627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,20 +25,18 @@\n       }}\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n-        const nextInitialY = (index + 1) * step;\n-        const endY = initialY * 0.1;\n-\n-        // top 계산 (스택처럼 올라오게)\n+        const overlapStartY = initialY + containerHeight * 0.1;\n         const visibleY = Math.max(0, initialY - scrollY);\n-        const top = Math.max(endY, visibleY);\n+        const top = Math.max(overlapStartY, visibleY);\n \n-        // 회전 계산 (다음 컨테이너가 도달하면 회전 시작)\n         const maxRotate = maxRotateXList[index];\n         let rotateX = 0;\n-        if (maxRotate !== 0 && scrollY >= nextInitialY) {\n-          const progress = Math.min(1, (scrollY - nextInitialY) / step);\n+\n+        const rotateStartY = initialY + containerHeight;\n+        if (maxRotate !== 0 && scrollY >= rotateStartY) {\n+          const progress = Math.min(1, (scrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n         }\n \n         return (\n@@ -49,9 +47,9 @@\n               top,\n               left: '50%',\n               transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               width: 1200,\n-              height: 600,\n+              height: containerHeight,\n               backgroundColor: color,\n               display: 'flex',\n               alignItems: 'center',\n               justifyContent: 'center',\n@@ -60,9 +58,8 @@\n               color: '#fff',\n               border: '2px solid #000',\n               transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n               zIndex: index,\n-\n             }}\n           >\n             {rotateX.toFixed(1)}°\n           </div>\n"
                },
                {
                    "date": 1747723113697,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,15 +25,17 @@\n       }}\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n-        const overlapStartY = initialY + containerHeight * 0.1;\n+        const endY = initialY * 0.1;\n+\n+        // ✅ 스크롤에 따라 위로 올라오게 하는 핵심 로직\n         const visibleY = Math.max(0, initialY - scrollY);\n-        const top = Math.max(overlapStartY, visibleY);\n+        const top = Math.max(endY, visibleY);\n \n+        // ✅ 회전 계산: 다음 컨테이너가 현재의 bottom에 닿았을 때부터\n         const maxRotate = maxRotateXList[index];\n         let rotateX = 0;\n-\n         const rotateStartY = initialY + containerHeight;\n         if (maxRotate !== 0 && scrollY >= rotateStartY) {\n           const progress = Math.min(1, (scrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n@@ -57,9 +59,9 @@\n               fontWeight: 'bold',\n               color: '#fff',\n               border: '2px solid #000',\n               transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n-              zIndex: index,\n+              zIndex: index, // 뒤에 있는 게 위로 올라오도록\n             }}\n           >\n             {rotateX.toFixed(1)}°\n           </div>\n"
                },
                {
                    "date": 1747723180118,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,9 +34,9 @@\n \n         // ✅ 회전 계산: 다음 컨테이너가 현재의 bottom에 닿았을 때부터\n         const maxRotate = maxRotateXList[index];\n         let rotateX = 0;\n-        const rotateStartY = initialY + containerHeight;\n+        const rotateStartY = 600;\n         if (maxRotate !== 0 && scrollY >= rotateStartY) {\n           const progress = Math.min(1, (scrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n         }\n"
                },
                {
                    "date": 1747723254879,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,8 +51,9 @@\n               transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               width: 1200,\n               height: containerHeight,\n               backgroundColor: color,\n+              perspective: '1000px',\n               display: 'flex',\n               alignItems: 'center',\n               justifyContent: 'center',\n               fontSize: '32px',\n"
                },
                {
                    "date": 1747723269997,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,9 +51,9 @@\n               transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               width: 1200,\n               height: containerHeight,\n               backgroundColor: color,\n-              perspective: '1000px',\n+              perspective: '10000px',\n               display: 'flex',\n               alignItems: 'center',\n               justifyContent: 'center',\n               fontSize: '32px',\n"
                },
                {
                    "date": 1747723390117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,9 +3,9 @@\n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n const gap = 100;\n const step = containerHeight + gap;\n-const maxRotateXList = [-30, -15, 0];\n+const maxRotateXList = [-300, -15, 0];\n \n const Container3DStackScroll: React.FC = () => {\n   const [scrollY, setScrollY] = useState(0);\n \n"
                },
                {
                    "date": 1747723406064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,7 @@\n import React, { useEffect, useState } from 'react';\n \n-const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n+const colors = ['#FF6B6B', ];\n const containerHeight = 600;\n const gap = 100;\n const step = containerHeight + gap;\n const maxRotateXList = [-300, -15, 0];\n"
                },
                {
                    "date": 1747723506384,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,11 @@\n import React, { useEffect, useState } from 'react';\n \n-const colors = ['#FF6B6B', ];\n+const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n const gap = 100;\n const step = containerHeight + gap;\n-const maxRotateXList = [-300, -15, 0];\n+const maxRotateXList = [-30, -15, 0];\n \n const Container3DStackScroll: React.FC = () => {\n   const [scrollY, setScrollY] = useState(0);\n \n@@ -21,22 +21,22 @@\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n         background: '#111',\n+        perspective: '1000px', // ✅ 부모에 원근감 적용\n+        overflowX: 'hidden',\n       }}\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n         const endY = initialY * 0.1;\n \n-        // ✅ 스크롤에 따라 위로 올라오게 하는 핵심 로직\n         const visibleY = Math.max(0, initialY - scrollY);\n         const top = Math.max(endY, visibleY);\n \n-        // ✅ 회전 계산: 다음 컨테이너가 현재의 bottom에 닿았을 때부터\n         const maxRotate = maxRotateXList[index];\n         let rotateX = 0;\n-        const rotateStartY = 600;\n+        const rotateStartY = initialY + containerHeight;\n         if (maxRotate !== 0 && scrollY >= rotateStartY) {\n           const progress = Math.min(1, (scrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n         }\n@@ -47,22 +47,23 @@\n             style={{\n               position: 'absolute',\n               top,\n               left: '50%',\n-              transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               width: 1200,\n               height: containerHeight,\n-              backgroundColor: color,\n-              perspective: '10000px',\n+              transform: `translateX(-50%) rotateX(${rotateX}deg)`, // ✅ 컨테이너에 회전 적용\n+              transformStyle: 'preserve-3d', // ✅ 회전 컨테이너에 3D 유지\n               display: 'flex',\n               alignItems: 'center',\n               justifyContent: 'center',\n+              backgroundColor: color,\n               fontSize: '32px',\n               fontWeight: 'bold',\n               color: '#fff',\n               border: '2px solid #000',\n               transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n-              zIndex: index, // 뒤에 있는 게 위로 올라오도록\n+              zIndex: index,\n+              willChange: 'transform',\n             }}\n           >\n             {rotateX.toFixed(1)}°\n           </div>\n"
                },
                {
                    "date": 1747723550275,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n         background: '#111',\n-        perspective: '1000px', // ✅ 부모에 원근감 적용\n+        perspective: '10000px', // ✅ 부모에 원근감 적용\n         overflowX: 'hidden',\n       }}\n     >\n       {colors.map((color, index) => {\n"
                },
                {
                    "date": 1747723582629,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n         background: '#111',\n-        perspective: '10000px', // ✅ 부모에 원근감 적용\n+        perspective: '100px', // ✅ 부모에 원근감 적용\n         overflowX: 'hidden',\n       }}\n     >\n       {colors.map((color, index) => {\n"
                },
                {
                    "date": 1747723592417,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n         background: '#111',\n-        perspective: '100px', // ✅ 부모에 원근감 적용\n+        perspective: '1000px', // ✅ 부모에 원근감 적용\n         overflowX: 'hidden',\n       }}\n     >\n       {colors.map((color, index) => {\n"
                },
                {
                    "date": 1747723685962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,25 +21,27 @@\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n         background: '#111',\n-        perspective: '1000px', // ✅ 부모에 원근감 적용\n+        perspective: '1000px',\n         overflowX: 'hidden',\n       }}\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n         const endY = initialY * 0.1;\n-\n         const visibleY = Math.max(0, initialY - scrollY);\n         const top = Math.max(endY, visibleY);\n \n         const maxRotate = maxRotateXList[index];\n         let rotateX = 0;\n+        let scale = 1;\n+\n         const rotateStartY = initialY + containerHeight;\n         if (maxRotate !== 0 && scrollY >= rotateStartY) {\n           const progress = Math.min(1, (scrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n+          scale = 1 - progress * 0.05; // ✅ 살짝 줄이기 (예: 최대 0.95)\n         }\n \n         return (\n           <div\n@@ -49,20 +51,21 @@\n               top,\n               left: '50%',\n               width: 1200,\n               height: containerHeight,\n-              transform: `translateX(-50%) rotateX(${rotateX}deg)`, // ✅ 컨테이너에 회전 적용\n-              transformStyle: 'preserve-3d', // ✅ 회전 컨테이너에 3D 유지\n+              backgroundColor: color,\n               display: 'flex',\n               alignItems: 'center',\n               justifyContent: 'center',\n-              backgroundColor: color,\n               fontSize: '32px',\n               fontWeight: 'bold',\n               color: '#fff',\n               border: '2px solid #000',\n+              zIndex: index,\n               transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n-              zIndex: index,\n+              transformStyle: 'preserve-3d',\n+              transformOrigin: 'top center', // ✅ 중심축 위쪽으로\n+              transform: `translateX(-50%) rotateX(${rotateX}deg) scale(${scale})`,\n               willChange: 'transform',\n             }}\n           >\n             {rotateX.toFixed(1)}°\n"
                },
                {
                    "date": 1747723700394,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n         const rotateStartY = initialY + containerHeight;\n         if (maxRotate !== 0 && scrollY >= rotateStartY) {\n           const progress = Math.min(1, (scrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n-          scale = 1 - progress * 0.05; // ✅ 살짝 줄이기 (예: 최대 0.95)\n+        //   scale = 1 - progress * 0.05; // ✅ 살짝 줄이기 (예: 최대 0.95)\n         }\n \n         return (\n           <div\n"
                },
                {
                    "date": 1747723744855,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n import React, { useEffect, useState } from 'react';\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n-const gap = 100;\n+const gap = 400;\n const step = containerHeight + gap;\n const maxRotateXList = [-30, -15, 0];\n \n const Container3DStackScroll: React.FC = () => {\n"
                },
                {
                    "date": 1747723754395,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n import React, { useEffect, useState } from 'react';\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n-const gap = 400;\n+const gap = 300;\n const step = containerHeight + gap;\n const maxRotateXList = [-30, -15, 0];\n \n const Container3DStackScroll: React.FC = () => {\n"
                },
                {
                    "date": 1747723886708,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,23 +1,32 @@\n-import React, { useEffect, useState } from 'react';\n+import React, { useEffect, useRef, useState } from 'react';\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n const gap = 300;\n const step = containerHeight + gap;\n const maxRotateXList = [-30, -15, 0];\n \n const Container3DStackScroll: React.FC = () => {\n-  const [scrollY, setScrollY] = useState(0);\n+  const containerRef = useRef<HTMLDivElement>(null);\n+  const [relativeScrollY, setRelativeScrollY] = useState(0);\n \n   useEffect(() => {\n-    const handleScroll = () => setScrollY(window.scrollY);\n+    const handleScroll = () => {\n+      if (containerRef.current) {\n+        const rect = containerRef.current.getBoundingClientRect();\n+        const relativeY = -rect.top; // 스크롤 기준: 컴포넌트 기준 상단이 위로 얼마나 올라갔는지\n+        setRelativeScrollY(relativeY);\n+      }\n+    };\n+    handleScroll(); // mount 시 초기화\n     window.addEventListener('scroll', handleScroll);\n     return () => window.removeEventListener('scroll', handleScroll);\n   }, []);\n \n   return (\n     <div\n+      ref={containerRef}\n       style={{\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n@@ -28,20 +37,18 @@\n     >\n       {colors.map((color, index) => {\n         const initialY = index * step;\n         const endY = initialY * 0.1;\n-        const visibleY = Math.max(0, initialY - scrollY);\n+\n+        const visibleY = Math.max(0, initialY - relativeScrollY);\n         const top = Math.max(endY, visibleY);\n \n         const maxRotate = maxRotateXList[index];\n         let rotateX = 0;\n-        let scale = 1;\n-\n         const rotateStartY = initialY + containerHeight;\n-        if (maxRotate !== 0 && scrollY >= rotateStartY) {\n-          const progress = Math.min(1, (scrollY - rotateStartY) / step);\n+        if (maxRotate !== 0 && relativeScrollY >= rotateStartY) {\n+          const progress = Math.min(1, (relativeScrollY - rotateStartY) / step);\n           rotateX = progress * maxRotate;\n-        //   scale = 1 - progress * 0.05; // ✅ 살짝 줄이기 (예: 최대 0.95)\n         }\n \n         return (\n           <div\n@@ -62,10 +69,10 @@\n               border: '2px solid #000',\n               zIndex: index,\n               transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n               transformStyle: 'preserve-3d',\n-              transformOrigin: 'top center', // ✅ 중심축 위쪽으로\n-              transform: `translateX(-50%) rotateX(${rotateX}deg) scale(${scale})`,\n+              transformOrigin: 'top center',\n+              transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n               willChange: 'transform',\n             }}\n           >\n             {rotateX.toFixed(1)}°\n"
                },
                {
                    "date": 1747723899351,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,9 +1,9 @@\n import React, { useEffect, useRef, useState } from 'react';\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n-const gap = 300;\n+const gap = 100;\n const step = containerHeight + gap;\n const maxRotateXList = [-30, -15, 0];\n \n const Container3DStackScroll: React.FC = () => {\n"
                },
                {
                    "date": 1747723979161,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,27 +1,44 @@\n import React, { useEffect, useRef, useState } from 'react';\n+import gsap from 'gsap';\n+import ScrollTrigger from 'gsap/ScrollTrigger';\n \n const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n const containerHeight = 600;\n const gap = 100;\n const step = containerHeight + gap;\n const maxRotateXList = [-30, -15, 0];\n \n+gsap.registerPlugin(ScrollTrigger);\n+\n const Container3DStackScroll: React.FC = () => {\n   const containerRef = useRef<HTMLDivElement>(null);\n+  const pinRef = useRef<HTMLDivElement>(null);\n   const [relativeScrollY, setRelativeScrollY] = useState(0);\n \n   useEffect(() => {\n+    if (!containerRef.current || !pinRef.current) return;\n+\n+    const ctx = gsap.context(() => {\n+      ScrollTrigger.create({\n+        trigger: pinRef.current,\n+        start: 'top top',\n+        end: () => `${colors.length * step}px`,\n+        pin: true,\n+        scrub: true,\n+      });\n+    }, containerRef);\n+\n     const handleScroll = () => {\n-      if (containerRef.current) {\n-        const rect = containerRef.current.getBoundingClientRect();\n-        const relativeY = -rect.top; // 스크롤 기준: 컴포넌트 기준 상단이 위로 얼마나 올라갔는지\n-        setRelativeScrollY(relativeY);\n-      }\n+      const rect = pinRef.current!.getBoundingClientRect();\n+      setRelativeScrollY(-rect.top);\n     };\n-    handleScroll(); // mount 시 초기화\n+\n     window.addEventListener('scroll', handleScroll);\n-    return () => window.removeEventListener('scroll', handleScroll);\n+    return () => {\n+      ctx.revert();\n+      window.removeEventListener('scroll', handleScroll);\n+    };\n   }, []);\n \n   return (\n     <div\n@@ -34,52 +51,54 @@\n         perspective: '1000px',\n         overflowX: 'hidden',\n       }}\n     >\n-      {colors.map((color, index) => {\n-        const initialY = index * step;\n-        const endY = initialY * 0.1;\n+      <div ref={pinRef} style={{ position: 'relative', height: step }}>\n+        {colors.map((color, index) => {\n+          const initialY = index * step;\n+          const endY = initialY * 0.1;\n \n-        const visibleY = Math.max(0, initialY - relativeScrollY);\n-        const top = Math.max(endY, visibleY);\n+          const visibleY = Math.max(0, initialY - relativeScrollY);\n+          const top = Math.max(endY, visibleY);\n \n-        const maxRotate = maxRotateXList[index];\n-        let rotateX = 0;\n-        const rotateStartY = initialY + containerHeight;\n-        if (maxRotate !== 0 && relativeScrollY >= rotateStartY) {\n-          const progress = Math.min(1, (relativeScrollY - rotateStartY) / step);\n-          rotateX = progress * maxRotate;\n-        }\n+          const maxRotate = maxRotateXList[index];\n+          let rotateX = 0;\n+          const rotateStartY = initialY + containerHeight;\n+          if (maxRotate !== 0 && relativeScrollY >= rotateStartY) {\n+            const progress = Math.min(1, (relativeScrollY - rotateStartY) / step);\n+            rotateX = progress * maxRotate;\n+          }\n \n-        return (\n-          <div\n-            key={index}\n-            style={{\n-              position: 'absolute',\n-              top,\n-              left: '50%',\n-              width: 1200,\n-              height: containerHeight,\n-              backgroundColor: color,\n-              display: 'flex',\n-              alignItems: 'center',\n-              justifyContent: 'center',\n-              fontSize: '32px',\n-              fontWeight: 'bold',\n-              color: '#fff',\n-              border: '2px solid #000',\n-              zIndex: index,\n-              transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n-              transformStyle: 'preserve-3d',\n-              transformOrigin: 'top center',\n-              transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n-              willChange: 'transform',\n-            }}\n-          >\n-            {rotateX.toFixed(1)}°\n-          </div>\n-        );\n-      })}\n+          return (\n+            <div\n+              key={index}\n+              style={{\n+                position: 'absolute',\n+                top,\n+                left: '50%',\n+                width: 1200,\n+                height: containerHeight,\n+                backgroundColor: color,\n+                display: 'flex',\n+                alignItems: 'center',\n+                justifyContent: 'center',\n+                fontSize: '32px',\n+                fontWeight: 'bold',\n+                color: '#fff',\n+                border: '2px solid #000',\n+                zIndex: index,\n+                transition: 'top 0.2s ease-out, transform 0.2s ease-out',\n+                transformStyle: 'preserve-3d',\n+                transformOrigin: 'top center',\n+                transform: `translateX(-50%) rotateX(${rotateX}deg)`,\n+                willChange: 'transform',\n+              }}\n+            >\n+              {rotateX.toFixed(1)}°\n+            </div>\n+          );\n+        })}\n+      </div>\n     </div>\n   );\n };\n \n"
                },
                {
                    "date": 1747724026433,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,8 +19,9 @@\n     if (!containerRef.current || !pinRef.current) return;\n \n     const ctx = gsap.context(() => {\n       ScrollTrigger.create({\n+        id:'3d',\n         trigger: pinRef.current,\n         start: 'top top',\n         end: () => `${colors.length * step}px`,\n         pin: true,\n"
                },
                {
                    "date": 1747724149178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,22 +19,25 @@\n     if (!containerRef.current || !pinRef.current) return;\n \n     const ctx = gsap.context(() => {\n       ScrollTrigger.create({\n-        id:'3d',\n+        id: '3d',\n         trigger: pinRef.current,\n         start: 'top top',\n         end: () => `${colors.length * step}px`,\n         pin: true,\n         scrub: true,\n+        // markers: true, // ← 개발 중 디버깅용 표시\n       });\n     }, containerRef);\n \n     const handleScroll = () => {\n       const rect = pinRef.current!.getBoundingClientRect();\n       setRelativeScrollY(-rect.top);\n     };\n \n+    handleScroll(); // 초기값 설정\n+\n     window.addEventListener('scroll', handleScroll);\n     return () => {\n       ctx.revert();\n       window.removeEventListener('scroll', handleScroll);\n@@ -52,9 +55,15 @@\n         perspective: '1000px',\n         overflowX: 'hidden',\n       }}\n     >\n-      <div ref={pinRef} style={{ position: 'relative', height: step }}>\n+      <div\n+        ref={pinRef}\n+        style={{\n+          position: 'relative',\n+          height: `${colors.length * step}px`, // ✅ pin 대상 height 늘림\n+        }}\n+      >\n         {colors.map((color, index) => {\n           const initialY = index * step;\n           const endY = initialY * 0.1;\n \n"
                },
                {
                    "date": 1747724214405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n   }, []);\n \n   return (\n     <div\n-      ref={containerRef}\n+      ref={pinRef}\n       style={{\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n"
                },
                {
                    "date": 1747724226220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,9 @@\n   }, []);\n \n   return (\n     <div\n-      ref={pinRef}\n+      ref={containerRef}\n       style={{\n         position: 'relative',\n         width: '100vw',\n         height: `${colors.length * step + 100}px`,\n"
                }
            ],
            "date": 1747721781486,
            "name": "Commit-0",
            "content": "import React, { useEffect, useRef, useState } from 'react';\n\nconst colors = ['#FF6B6B', '#4ECDC4', '#FFD93D'];\n\nconst Container3D: React.FC = () => {\n  const [rotateY, setRotateY] = useState(0);\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const handleWheel = (e: WheelEvent) => {\n    e.preventDefault();\n    setRotateY(prev => prev + e.deltaY * 0.1);\n  };\n\n  useEffect(() => {\n    const el = containerRef.current;\n    if (el) {\n      el.addEventListener('wheel', handleWheel, { passive: false });\n    }\n    return () => {\n      if (el) {\n        el.removeEventListener('wheel', handleWheel);\n      }\n    };\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        width: '100vw',\n        height: '100vh',\n        perspective: '1000px',\n        display: 'flex',\n        alignItems: 'center',\n        justifyContent: 'center',\n        overflow: 'hidden',\n        background: '#111',\n      }}\n    >\n      <div\n        style={{\n          width: 1200,\n          height: 600,\n          display: 'flex',\n          transformStyle: 'preserve-3d',\n          transform: `rotateY(${rotateY}deg)`,\n          transition: 'transform 0.1s ease-out',\n        }}\n      >\n        {colors.map((color, index) => (\n          <div\n            key={index}\n            style={{\n              width: 400,\n              height: 600,\n              backgroundColor: color,\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              fontSize: '32px',\n              fontWeight: 'bold',\n              color: '#fff',\n              border: '1px solid #000',\n            }}\n          >\n            {Math.round(rotateY)}°\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default Container3D;\n"
        }
    ]
}